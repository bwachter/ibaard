.TH "/home/travis/build/bwachter/ibaard/src/netread.c" 3 "Thu Nov 15 2018" "ibaard" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/travis/build/bwachter/ibaard/src/netread.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'ibaard_network\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBnetread\fP (int sd, char *buf)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBAuthor:\fP
.RS 4
Bernd Wachter bwachter@lart.info 
.RE
.PP
\fBDate:\fP
.RS 4
2005-2011 
.RE
.PP

.PP
Definition in file \fBnetread\&.c\fP\&.
.SH "Function Documentation"
.PP 
.SS "int netread (intsd, char *buf)"
Read data from a file descriptor
.PP
\fBnetread()\fP reads up to MAXNETBUF bytes from a given file descriptor and returns the number of bytes read\&. The read bytes are stored (NULL- terminated) in the buffer specified by buf\&. You need to make sure that buf has enough space for MAXNETBUF + 1 bytes\&.
.PP
\fBnetread()\fP, as well as the the functions \fBnetreadline()\fP and \fBnetwriteline()\fP can handle both plaintext and SSL\&. If there's an open SSL connection they'll use SSL, if not they'll read/write plaintext\&.
.PP
\fBTodo\fP
.RS 4
complete documentation 
.RE
.PP

.PP
Definition at line 9 of file netread\&.c\&.
.PP
.nf
9                               {
10   int i;
11 #if (defined HAVE_SSL) || (defined HAVE_MATRIXSSL)
12   if (am_sslconf & AM_SSL_USETLS){
13     i=netsslread(ssl, buf, MAXNETBUF);
14   } else
15 #endif
16     i=recv(sd, buf, MAXNETBUF, 0);
17   buf[i]='\0';
18   return i;
19 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ibaard from the source code\&.
